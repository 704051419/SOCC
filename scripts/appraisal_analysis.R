# code is still in development

library(tokenizers)   # used to re-calculate number of words for graphs
library(ggplot2)      # makes graphs
library(reshape2)     # prepares data for graphing
library(viridis)      # color schemes for graphs

###### Getting the annotation dataframes ######
# Read file
appraisal.annotations <- read.csv("~/_My Actual Folders/Research/Discourse Processing/socc_comments/combined_appraisal_comments.csv")
negation.annotations <- read.csv("~/_My Actual Folders/Research/Discourse Processing/socc_comments/combined_negation_comments.csv")

# remove the extra column
appraisal.annotations <- appraisal.annotations[,2:length(appraisal.annotations)]
negation.annotations <- negation.annotations[,2:length(negation.annotations)]

# Check for any blank appraisal.annotations
mismatches = subset(appraisal.annotations,
                    appraisal.annotations$attlab == "*" | appraisal.annotations$attpol == "*" | appraisal.annotations$gralab == "*" | appraisal.annotations$grapol == "*")

###### Overlaying negation ######
## check that all comment names match
appraisal.comments = unique(as.character(appraisal.annotations$comment))
negation.comments = unique(as.character(negation.annotations$comment))
comment.matching = data.frame(comment = c(appraisal.comments, negation.comments),
                              appraisal = NA,
                              negation = NA)
comment.matching$appraisal = comment.matching$comment %in% appraisal.comments
comment.matching$negation = comment.matching$comment %in% negation.comments
comment.matching$both = comment.matching$appraisal && comment.matching$negation

# comments not in both
# subset(comment.matching, !both)
# comments in only appraisal
# subset(comment.matching, appraisal & !negation)
# comments in only negation
# subset(comment.matching, !appraisal & negation)
# All of those subsets have no rows, so all comments in one df are in the other.

## add in a column to appraisal.annotations to show whether there is a NEG keyword in the span
appraisal.annotations$NEG = FALSE
negdf = subset(negation.annotations, label=='NEG')

# Mark $NEG as TRUE if there's a NEG keyword there
for (i in 1:length(negdf$label))
{
  appdf = appraisal.annotations[appraisal.annotations$comment == negdf$comment[i],]
  for (j in 1:length(appdf$comment))
  {
    if (negdf$charend[i] > appdf$charstart[j] & negdf$charend[i] <= appdf$charend[j])
    {
      appraisal.annotations[appraisal.annotations$comment == negdf$comment[i],]$NEG[j] = TRUE
    }
  }
  bar = txtProgressBar(style=3)
  setTxtProgressBar(bar, value=i/length(negdf$label))
}
close(bar)

###### Getting basic counts ######
# So that we can count them later, get subsets of "appraisal.annotations" by label
# Attitude labels
attrows = subset(appraisal.annotations, attlab != "None")
approws = appraisal.annotations[appraisal.annotations$attlab=="Appreciation",]
judrows = appraisal.annotations[appraisal.annotations$attlab=="Judgment",]
affrows = appraisal.annotations[appraisal.annotations$attlab=="Affect",]
# Attitude polarities
posrows = appraisal.annotations[appraisal.annotations$attpol=="pos",]
negrows = appraisal.annotations[appraisal.annotations$attpol=="neg",]
neurows = appraisal.annotations[appraisal.annotations$attpol=="neu",]
# Graduation labels
grarows = subset(appraisal.annotations, gralab != "None")
forcerows = appraisal.annotations[appraisal.annotations$gralab=="Force",]
focusrows = appraisal.annotations[appraisal.annotations$gralab=="Focus",]
# Graduation polarities
upgradrows = appraisal.annotations[appraisal.annotations$grapol=="up",]
downgradrows = appraisal.annotations[appraisal.annotations$grapol=="down",]

## Appraisal
# get simple counts
# Attitude labels
appcount = length(approws$attlab)
judcount = length(judrows$attlab)
affcount = length(affrows$attlab)
# Attitude polarities
poscount = length(posrows$attpol)
negcount = length(negrows$attpol)
neucount = length(neurows$attpol)
# Graduation labels
forcecount = length(forcerows$gralab)
focuscount = length(focusrows$gralab)
# Graduation polarities
upgradcount = length(upgradrows$grapol)
downgradcount = length(downgradrows$grapol)

# Make dataframes to put counts of matched labels and polarities in
attcounts = data.frame(row.names = c("neg", "pos", "neu", "total"))
gracounts = data.frame(row.names = c("up", "down", "total"))

# put in counts for Attitude
attcounts$appreciation = c(
  length(approws[approws$attpol=="neg",]$attlab),  # count of negative appreciation
  length(approws[approws$attpol=="pos",]$attlab),  # count of positive appreciation
  length(approws[approws$attpol=="neu",]$attlab),  # count of neutral appreciation
  length(approws$attlab)                           # count of all appreciation
)

attcounts$judgment = c(
  length(judrows[judrows$attpol=="neg",]$attlab),
  length(judrows[judrows$attpol=="pos",]$attlab),
  length(judrows[judrows$attpol=="neu",]$attlab),
  length(judrows$attlab)
)

attcounts$affect = c(
  length(affrows[affrows$attpol=="neg",]$attlab),
  length(affrows[affrows$attpol=="pos",]$attlab),
  length(affrows[affrows$attpol=="neu",]$attlab),
  length(affrows$attlab)
)

attcounts$total = attcounts$appreciation + attcounts$judgment + attcounts$affect

# put in counts for Graduation
gracounts$force = c(
  length(forcerows[forcerows$grapol=="up",]$gralab),
  length(forcerows[forcerows$grapol=="down",]$gralab),
  length(forcerows$gralab)
)

gracounts$focus = c(
  length(focusrows[focusrows$grapol=="up",]$gralab),
  length(focusrows[focusrows$grapol=="down",]$gralab),
  length(focusrows$gralab)
)

gracounts$total = gracounts$force + gracounts$focus

## Negation
negcounts = data.frame( row.names = c("neg", "pos", "neu", "all pols"))
# a function to count the percentage of spans with negation given a DF
countnegs <- function(df){
  length(rownames(subset(df, NEG == TRUE))) / length(rownames(df))
}
# get the counts
negcounts$app = c(
  countnegs(subset(approws, attpol == "neg")),
  countnegs(subset(approws, attpol == "pos")),
  countnegs(subset(approws, attpol == "neu")),
  countnegs(approws)
)
negcounts$jud = c(
  countnegs(subset(judrows, attpol == "neg")),
  countnegs(subset(judrows, attpol == "pos")),
  countnegs(subset(judrows, attpol == "neu")),
  countnegs(judrows)
)
negcounts$aff = c(
  countnegs(subset(affrows, attpol == "neg")),
  countnegs(subset(affrows, attpol == "pos")),
  countnegs(subset(affrows, attpol == "neu")),
  countnegs(affrows)
)
negcounts$all.labs = c(
  countnegs(subset(attrows, attpol == "neg")),
  countnegs(subset(attrows, attpol == "pos")),
  countnegs(subset(attrows, attpol == "neu")),
  countnegs(attrows)
)

###### Finding stacked spans ######

# find stacked spans
print("Looking for stacked spans.")
stacks = appraisal.annotations[0,]
look = 7     # how far ahead to look
punctuation = c(".", ",", "!", "?")
for(i in 1:length(appraisal.annotations$span))
{
  for(n in 1:look)
  {
    if (match(i+n, 1:length(appraisal.annotations$span), nomatch=FALSE))
    {
      if(appraisal.annotations$charstart[i+n] <= appraisal.annotations$charend[i]  # if the charstart for the 'next' is less than charstart for this one
         & appraisal.annotations$comment[i+n] == appraisal.annotations$comment[i]  # and the two are in the same comment
         & !(appraisal.annotations$span[i] %in% punctuation)             # and this span is not just punctuation
         & !(appraisal.annotations$span[i+n] %in% punctuation))          # and neither is the 'next' one
      {
        stacks = rbind(appraisal.annotations[i,], stacks)  # then add this row to stacks
        stacks = rbind(appraisal.annotations[i+n,], stacks) # and the 'next' one
      }
    }
  }
  bar = txtProgressBar(style=3)
  setTxtProgressBar(bar, value=i/length(appraisal.annotations$span))
}
close(bar)
stacks = unique(stacks)
stacks = stacks[order(stacks$comment, stacks$charstart),]

# get a data.frame of all spans with graduation and the attitude spans that contain them
print("Looking for stacked graduation.")
graduation = stacks[0,]
look = 6     # how far ahead to look
for(i in 1:length(stacks$span))
{
  for(n in 1:look)
  {
    # look ahead, if we see a grad annotation for this comment and an attitude one for an overlapping future one then we can include them
    if (match(i+n, 1:length(stacks$span), nomatch=FALSE))
    {
      if(stacks$charstart[i+n] <= stacks$charend[i]  # if the charstart for the 'next' is less than charend for this one
         & stacks$comment[i+n] == stacks$comment[i]  # and the two are in the same comment
         & (stacks$gralab[i] != "None" | stacks$grapol[i] != "None")  # and there's a graduation annotation in this row
         & (stacks$attlab[i+n] != "None" | stacks$attpol[i+n] != "None") # and an attitude annotation in the 'next' one
         )
      {
        graduation = rbind(stacks[i,], graduation)  # then add this row to the df (graduation annotation)
        graduation = rbind(stacks[i+n,], graduation) # and the 'next' one (attitude annotation)
      }
    }
    # look behind for the same thing
    if (match(i-n, 1:length(stacks$span), nomatch=FALSE))
    {
      if(stacks$charstart[i] <= stacks$charend[i-n]  # if the charstart for this one is greater than charend for the 'previous' one
         & stacks$comment[i-n] == stacks$comment[i]  # and the two are in the same comment
         & (stacks$gralab[i] != "None" | stacks$grapol[i] != "None")  # and there's a graduation annotation in this row
         & (stacks$attlab[i-n] != "None" | stacks$attpol[i-n] != "None") # and an attitude annotation in the 'previous' one
      )
      {
        graduation = rbind(stacks[i,], graduation)  # then add this row to the df (graduation annotation)
        graduation = rbind(stacks[i-n,], graduation) # and the 'previous' one (attitude annotation)
      }
    }
  }
  bar = txtProgressBar(style=3)
  setTxtProgressBar(bar, value=i/length(stacks$span))
}
close(bar)

graduation = unique(graduation)
graduation = graduation[order(graduation$comment, graduation$charstart),]
graduation.oldnames = graduation # this df's rownames will be indices for the appraisal.annotations df
rownames(graduation) = 1:length(graduation$span)

# add column for scope of graduation
look = 10
# find all rows with graduation (should be the same as focusrows + forcerows)
candidates = graduation[graduation$grapol != "None" | graduation$gralab != "None",]
# make a key so we know the original index of each row
index.key = c()
for (i in 1:length(candidates$span))
{
  index.key[i] = strtoi(rownames(candidates[i,]))
}
# e.g. index.key[1] returns "15," meaning 15 is the original index of candidates[1,]
graduation$scope_of = 0
for(i in 1:length(candidates$span))
{
  graduation$scope_of[index.key[i]] = 0
  for(n in 1:look)
  {
    if(match(index.key[i]+n, 1:length(graduation$span), nomatch=FALSE))
    {
      if(graduation$charstart[index.key[i]+n] <= graduation$charend[index.key[i]] 
        & graduation$comment[index.key[i]+n] == graduation$comment[index.key[i]]) # same thing as before checking for overlap
      {
        graduation$scope_of[index.key[i]+n] = index.key[i]
      }
    }
    if(match(index.key[i]-n, 1:length(graduation$span), nomatch=FALSE))
    {
      if (graduation$charstart[index.key[i]] <= graduation$charend[index.key[i]-n] # but looking backwards too
          & graduation$comment[index.key[i]-n] == graduation$comment[index.key[i]])
      {
        graduation$scope_of[index.key[i]-n] = index.key[i]
      }
    }
  }
  bar = txtProgressBar(style=3)
  setTxtProgressBar(bar, value=i/length(candidates$span))
}
close(bar)

graduation$belongs_to = 0
for(i in 1:length(candidates$span))
{
  graduation$belongs_to[index.key[i]] = 0
  for(n in 1:look)
  {
    if(match(index.key[i]-n, 1:length(graduation$span), nomatch=FALSE))
    {
      if (graduation$charstart[index.key[i]] <= graduation$charend[index.key[i]-n] # looking backwards only
          & graduation$comment[index.key[i]-n] == graduation$comment[index.key[i]])
      {
        graduation$belongs_to[index.key[i]] = index.key[i]-n
      }
    }
  }
  bar = txtProgressBar(style=3)
  setTxtProgressBar(bar, value=i/length(candidates$span))
}
close(bar)

# find graduation spans with ambiguous scopes
graduation.ambig = graduation[0,]
look = 5
for(i in 1:length(graduation$span))
{
  for(n in 1:look)
  {
    if (match(i+n, 1:length(graduation$span), nomatch=FALSE))
    {
      if(graduation$scope_of[i] != 0 # look for matching scopes, signaling ambiguity
         & graduation$scope_of[i] == graduation$scope_of[i+n])
      {
        # add this row to graduation.ambig
        graduation.ambig = rbind(graduation[i,], graduation.ambig)
        # and the next one
        graduation.ambig = rbind(graduation[i+n,], graduation.ambig)
        # and the one of which this is the scope
        graduation.ambig = rbind(graduation[graduation$scope_of[i],], graduation.ambig)
      }
    }
  }
  bar = txtProgressBar(style=3)
  setTxtProgressBar(bar, value=i/length(graduation$span))
}
close(bar)

graduation.ambig = unique(graduation.ambig)
# order the rows properly
neworder = c()
for (i in 1:length(rownames(graduation.ambig))) neworder[i] = strtoi(rownames(graduation.ambig)[i])
graduation.ambig = graduation.ambig[order(neworder),]

# this doesn't include cases where there's multiple graduation in one attitude, e.g. graduation[53:57,]

###### Getting counts by comment ######

# make a dataframe with one column, each of which is a unique comment id
comment.counts = data.frame(unique(appraisal.annotations$comment))
colnames(comment.counts) = 'comment'

#### using the comment IDs, fill in comment length and count
### start by making empty columns
# length info
comment.counts$charlength = NA
comment.counts$wordlength = NA
comment.counts$sentlength = NA

# attitude info
comment.counts$att = NA

comment.counts$appneg = NA
comment.counts$apppos = NA
comment.counts$appneu = NA

comment.counts$judneg = NA
comment.counts$judpos = NA
comment.counts$judneu = NA

comment.counts$affneg = NA
comment.counts$affpos = NA
comment.counts$affneu = NA

# graduation info
comment.counts$gra = NA

comment.counts$forceup = NA
comment.counts$forcedown = NA

comment.counts$focusup = NA
comment.counts$focusdown = NA

### then fill them in
## starting with basic counts

for (i in 1:length(comment.counts$comment)){
  # subset the dataframe
  df = appraisal.annotations[appraisal.annotations$comment == comment.counts$comment[i],]
  # length by word
  comment.counts$charlength[i] = max(df$charend)
  # length by word
  words = paste(df$span, collapse = '')
  words.tokenized = tokenize_words(words, simplify = TRUE)
  comment.counts$wordlength[i] = length(words.tokenized)
  # length by sentence
  comment.counts$sentlength[i] = max(df$sentend)
  # counts for attitude
  comment.counts$att[i] = length(df[df$attlab != 'None' |
                                      df$attpol != 'None',]$attlab)
  comment.counts$appneg[i] = length(df[df$attlab == 'Appreciation' &
                                         df$attpol == 'neg',]$attlab)
  comment.counts$apppos[i] = length(df[df$attlab == 'Appreciation' &
                                         df$attpol == 'pos',]$attlab)
  comment.counts$appneu[i] = length(df[df$attlab == 'Appreciation' &
                                         df$attpol == 'neu',]$attlab)
  
  comment.counts$judneg[i] = length(df[df$attlab == 'Judgment' &
                                         df$attpol == 'neg',]$attlab)
  comment.counts$judpos[i] = length(df[df$attlab == 'Judgment' &
                                         df$attpol == 'pos',]$attlab)
  comment.counts$judneu[i] = length(df[df$attlab == 'Judgment' &
                                         df$attpol == 'neu',]$attlab)
  
  comment.counts$affneg[i] = length(df[df$attlab == 'Affect' &
                                         df$attpol == 'neg',]$attlab)
  comment.counts$affpos[i] = length(df[df$attlab == 'Affect' &
                                         df$attpol == 'pos',]$attlab)
  comment.counts$affneu[i] = length(df[df$attlab == 'Affect' &
                                         df$attpol == 'neu',]$attlab)
  # counts for graduation
  comment.counts$gra[i] = length(df[df$gralab != 'None' |
                                          df$grapol != 'None',]$gralab)
  comment.counts$forceup[i] = length(df[df$gralab == 'Force' &
                                          df$grapol == 'up',]$gralab)
  comment.counts$forcedown[i] = length(df[df$gralab == 'Force' &
                                            df$grapol == 'down',]$gralab)
  
  comment.counts$focusup[i] = length(df[df$gralab == 'Focus' &
                                          df$grapol == 'up',]$gralab)
  comment.counts$focusdown[i] = length(df[df$gralab == 'Focus' &
                                            df$grapol == 'down',]$gralab)
  bar = txtProgressBar(style=3)
  setTxtProgressBar(bar, value=i/length(comment.counts$comment))
}
close(bar)

## aggregate info
comment.counts$app = comment.counts$appneg + comment.counts$apppos + comment.counts$appneu
comment.counts$jud = comment.counts$judneg + comment.counts$judpos + comment.counts$judneu
comment.counts$aff = comment.counts$affneg + comment.counts$affpos + comment.counts$affneu

comment.counts$pos = comment.counts$apppos + comment.counts$affpos + comment.counts$judpos
comment.counts$neg = comment.counts$appneg + comment.counts$affneg + comment.counts$judneg
comment.counts$neu = comment.counts$appneu + comment.counts$affneu + comment.counts$judneu

comment.counts$force = comment.counts$forcedown + comment.counts$forceup
comment.counts$focus = comment.counts$focusdown + comment.counts$focusup

comment.counts$up = comment.counts$focusup + comment.counts$forceup
comment.counts$down = comment.counts$focusdown + comment.counts$forcedown

## and percent aggregate info
comment.counts$apppct = comment.counts$app/comment.counts$att
comment.counts$judpct = comment.counts$jud/comment.counts$att
comment.counts$affpct = comment.counts$aff/comment.counts$att

comment.counts$negpct = comment.counts$neg/comment.counts$att
comment.counts$pospct = comment.counts$pos/comment.counts$att
comment.counts$neupct = comment.counts$neu/comment.counts$att

comment.counts$forcepct = comment.counts$force/comment.counts$gra
comment.counts$focuspct = comment.counts$focus/comment.counts$gra

comment.counts$uppct = comment.counts$up/comment.counts$gra
comment.counts$downpct = comment.counts$down/comment.counts$gra

## Graduation/att
comment.counts$gra.att = comment.counts$gra/comment.counts$att

#### Count details ####
### Att polarity
## pos vs neg
comment.counts$posratio = (comment.counts$pos/(comment.counts$pos + comment.counts$neg) -
                             comment.counts$neg/(comment.counts$pos + comment.counts$neg))
comment.counts$catpos = comment.counts$posratio > 0
comment.counts$catneg = comment.counts$posratio < 0
# how many negative spans in positive comments?
df = subset(comment.counts, catpos, select = c('comment', 'pos', 'neg', 'neu', 'catpos'))
length(df$comment)
# 134 total comments
sum(df$neg) + sum(df$pos)
# 797 total neg or pos spans
sum(df$neg)
# 219 = 27% neg in pos comments
sum(df$pos)
# 578 = 73% pos in pos comments
sum(df$neu)
# 10 neu in pos comments

# how many positive spans in negative comments?
df = subset(comment.counts, catneg, select = c('comment', 'pos', 'neg', 'neu', 'catneg'))
length(df$comment)
# 823 total comments
sum(df$neg) + sum(df$pos)
# 5394 pos or neg spans
sum(df$pos)
# 928 = 17% pos in neg comments
sum(df$neg)
# 4466 = 83% neg in neg comments

## comments with neu
df = subset(comment.counts, select = c("comment", "pospct", "negpct", "neupct",'catpos','catneg'))
df = df[df$neupct > 0,]   # filters out comments with no neu spans
# how many are there?
length(df$comment)
# 168
# how many totally positive (aside from neu)?
length(subset(df, negpct == 0)$comment)
# 3 = 2%
# how many are mostly positive?
length(subset(df, catpos)$comment)
# 24 = 14%
# mostly negative?
length(subset(df,catneg)$comment)
# 117 = 67%
# totally negative (aside from neu)?
length(subset(df, pospct == 0)$comment)
# 16 = 10%
# truly balanced?
length(subset(df,!catpos & !catneg)$comment)
# 15 = 9%

###### Analyzing negation ######


## What percent of evaluative spans have negation?
# Rows with any attitude
length(rownames(subset(attrows, NEG == TRUE))) / length(rownames(attrows))
# 0.1298505

###### Visualization #####
# often need to reshape the comment counts so that they work with ggplot; melt() does this
# see http://seananderson.ca/2013/10/19/reshape/ for more info on that
## aesthetic variable setting:
fill.alpha = .5
line.color = "black" # used for histograms
txtsize = 28
palette = viridis(n=3, option= "plasma")
##### By comment #####
#### General plots per word ####
df = subset(comment.counts, select = c("comment"))
#df$attrate = comment.counts$att/comment.counts$wordlength
df$grarate = comment.counts$gra/comment.counts$wordlength
df = melt(df)
# as density plot
ggplot(data = df, mapping=aes(value, fill=variable)) + geom_density(alpha = fill.alpha)

#### Attitude ####

## Percentages of attitude polarity
# somewhat answers: do comments tend to have spans with the same polarity in them?
df = subset(comment.counts, select = c("comment", "pospct", "negpct", "neupct"))
df = df[df$pospct > 0 | df$negpct > 0 | df$neupct >0,]   # filters out comments with no pos, neu, or neg spans
df = melt(df)
# as histogram
ggplot(data=df,mapping=aes(value, fill = variable, color = line.color)) +
  geom_histogram(data = df[df$variable=="pospct",], color = line.color, aes(fill = variable), alpha = fill.alpha) +
  geom_histogram(data = df[df$variable=="negpct",], color = line.color, aes(fill = variable), alpha = fill.alpha) +
  geom_histogram(data = df[df$variable=="neupct",], color = line.color, aes(fill = variable), alpha = fill.alpha) +
  labs(title = "Attitude polarity by comment", x = "Percentage") +
  scale_fill_discrete(name="Polarity",
                      breaks=c("pospct", "negpct", "neupct"),
                      labels=c("Positive", "Negative", "Neutral")) +
  theme(text = element_text(size=txtsize))

# as density plot
ggplot(data=df,mapping=aes(value, fill = variable)) +
  geom_density(alpha = fill.alpha, bw =.025) +
  labs(title = "Attitude polarity by comment", x = "Percentage") +
  scale_fill_manual(name="Polarity",
                    values = palette,
                    breaks=c("negpct", "pospct", "neupct"),
                    labels=c("Negative", "Positive", "Neutral")) +
  theme(text = element_text(size=txtsize))

## Same plot, but looking only at comments with neu
df = subset(comment.counts, select = c("comment", "pospct", "negpct", "neupct"))
df = df[df$neupct > 0,]   # filters out comments with no neu spans
df = melt(df)
# as density plot
ggplot(data=df,mapping=aes(value, fill = variable)) +
  geom_density(alpha = fill.alpha) +
  labs(title = "Attitude polarity by comment, only comments with neutral spans", x = "Percentage") +
  scale_fill_manual(name="Polarity",
                    values = palette,
                    breaks=c("negpct", "pospct", "neupct"),
                    labels=c("Negative", "Positive", "Neutral")) +
  theme(text = element_text(size=txtsize))
# as histogram
ggplot(data=df,mapping=aes(value)) +
  geom_histogram(data = df[df$variable=="pospct",], color = line.color, aes(fill = variable), alpha = fill.alpha) +
  geom_histogram(data = df[df$variable=="negpct",], color = line.color, aes(fill = variable), alpha = fill.alpha) +
  geom_histogram(data = df[df$variable=="neupct",], color = line.color, aes(fill = variable), alpha = fill.alpha) +
  labs(title = "Polarity by comment", x = "Percentage") +
  scale_fill_discrete(name = "Polarity",
                      breaks=c("pospct", "negpct", "neupct"),
                      labels=c("Positive", "Negative", "Neutral")) +
  theme(text = element_text(size=txtsize))

## looking only at comments with neu, pospct - negpct
df = subset(comment.counts, neupct > 0, select = c("comment", "neupct", "posratio"))
# density plot
ggplot(mapping=aes(df$posratio)) + geom_density(fill = "purple", alpha = fill.alpha) +
  labs(title = "Positivity of comment attitudes", x="percent of positive spans minus percent of negative spans") +
  theme(text = element_text(size=txtsize))
# histogram
ggplot(mapping=aes(df$posratio)) + geom_histogram() +
  labs(title = "Positivity of comment attitudes", x="percent of positive spans minus percent of negative spans") +
  theme(text = element_text(size=txtsize))

## Ignoring neutral spans, positive pct - negative pct
# attempts to further answer whether comments favor one polarity of span
df = subset(comment.counts, select = c("comment", "pos", "neg", "posratio"))
df = df[df$pos > 0 | df$neg > 0,]   # filters out comments with no pos or neg spans
ggplot(mapping=aes(df$posratio)) + geom_density(fill = "purple", alpha = fill.alpha) +
  labs(title = "Positivity of comment attitudes", x="percent of positive spans minus percent of negative spans") +
  theme(text = element_text(size=txtsize))

## Percentages of attitude label
# this gives an idea of how prevalent the different labels are
df = subset(comment.counts, select = c("comment", "apppct", "judpct", "affpct"))
df = df[df$apppct > 0 | df$judpct > 0,]   # filters out comments with no app or jud spans
df = melt(df)
# as density plot
ggplot(data=df,mapping=aes(value, fill=variable)) +
  geom_density(alpha = fill.alpha) +
  labs(title = "Attitude label by comment", x = "Percentage") +
  scale_fill_manual(name="Label",
                    values = palette,
                    breaks=c("apppct", "judpct", "affpct"),
                    labels=c("Appreciation", "Judgment", "Affect")) +
  theme(text = element_text(size=txtsize))

# as histogram
ggplot(data=df,mapping=aes(value)) +
  geom_histogram(data = df[df$variable=="apppct",], color = line.color, aes(fill = variable), alpha = fill.alpha) +
  geom_histogram(data = df[df$variable=="judpct",], color = line.color, aes(fill = variable), alpha = fill.alpha) +
  geom_histogram(data = df[df$variable=="affpct",], color = line.color, aes(fill = variable), alpha = fill.alpha) +
  labs(title = "Polarity by comment") +
  scale_fill_discrete(name="Polarity",
                      breaks=c("apppct", "judpct", "affpct"),
                      labels=c("Appreciation", "Judgment", "Affect")) +
  theme(text = element_text(size=txtsize))

## Same thing but without affect:
# lets us see that judgment and appreciation have similar distributions
df = subset(comment.counts, select = c("comment", "apppct", "judpct"))
df = df[df$apppct > 0 | df$judpct > 0,]   # filters out comments with no app or jud spans
df = melt(df)
# as density plot
ggplot(data=df,mapping=aes(value, fill=variable))  +
  geom_density(alpha = fill.alpha) +
  labs(title = "Attitude label by comment, affect excluded", x = "Percentage") +
  scale_fill_manual(name="Label",
                    values = palette,
                    breaks=c("apppct", "judpct", "affpct"),
                    labels=c("Appreciation", "Judgment", "Affect")) +
  theme(text = element_text(size=txtsize))
# as histogram
ggplot(data=df,mapping=aes(value)) +
  geom_histogram(data = df[df$variable=="apppct",], color = line.color, aes(fill = variable), alpha = fill.alpha) +
  geom_histogram(data = df[df$variable=="judpct",], color = line.color, aes(fill = variable), alpha = fill.alpha) +
  labs(title = "Type of Attitude by comment") +
  scale_fill_manual(name="Label",
                    values = palette,
                    breaks=c("apppct", "judpct", "affpct"),
                    labels=c("Appreciation", "Judgment", "Affect")) +
  theme(text = element_text(size=txtsize))

## Ignoring affect, apprec pct - jud pct
# attempts to further answer whether comments favor one polarity of span
df = subset(comment.counts, select = c("comment", "app", "jud"))
df = df[df$app > 0 | df$jud > 0,]   # filters out comments with no app or jud spans
df$appratio = (df$app/(df$app + df$jud) - df$jud/(df$app + df$jud))
# density plot
ggplot(mapping=aes(df$appratio)) + geom_density(fill = "purple", alpha = fill.alpha) +
  labs(title = "Preference of comments for Appreciation over Judgment", x="percent of Appreciation spans minus percent of Judgment spans") +
  theme(text = element_text(size=txtsize))
# histogram with few bins
ggplot(data=df,mapping=aes(appratio)) +
  geom_histogram(color = line.color, fill="purple", alpha = fill.alpha, bins=9) +
  labs(title = "Preference of comments for Appreciation over Judgment", x="percent of Appreciation spans minus percent of Judgment spans") +
  theme(text = element_text(size=txtsize))

## Same idea, but looking only at comments with affect (so with affect included)
# shows that even in comments with affect, the percentage is low, and there's about even amounts of judgment and appreciation
df = subset(comment.counts, select = c("comment", "apppct", "judpct", "affpct"))
df = df[df$affpct > 0,]   # filters out comments with no aff spans
df = melt(df)
# as histogram
ggplot(data=df,mapping=aes(value)) +
  geom_histogram(data = df[df$variable=="apppct",], color = line.color, aes(fill = variable), alpha = fill.alpha) +
  geom_histogram(data = df[df$variable=="judpct",], color = line.color, aes(fill = variable), alpha = fill.alpha) +
  geom_histogram(data = df[df$variable=="affpct",], color = line.color, aes(fill = variable), alpha = fill.alpha) +
  labs(title = "Polarity by comment") +
  scale_fill_discrete(name="Polarity",
                      breaks=c("apppct", "judpct", "affpct"),
                      labels=c("Appreciation", "Judgment", "Affect")) +
  theme(text = element_text(size=txtsize))
# as density plot
ggplot(data=df,mapping=aes(value, fill=variable))  +
  geom_density(alpha = fill.alpha) +
  labs(title = "Attitude label by comment, only comments with affect", x = "Percentage") +
  scale_fill_manual(name="Label",
                    values = palette,
                    breaks=c("apppct", "judpct", "affpct"),
                    labels=c("Appreciation", "Judgment", "Affect")) +
  theme(text = element_text(size=txtsize))

#### Graduation ####
# A smaller df with only comments that have graduation
graduation.comment.counts = comment.counts[comment.counts$gra > 0,]

## Graduation per Attitude
df = graduation.comment.counts$gra.att
# density
ggplot(mapping=aes(df)) + geom_density(fill = "purple", alpha = fill.alpha) +
  labs(title = "Graduation spans per Attitude span", x = "Graduation spans per Attitude span") +
  theme(text = element_text(size=txtsize))
# hist
ggplot(mapping=aes(df)) + geom_histogram(bins=20) +
  labs(title = "Graduation spans per Attitude span", x = "Graduation spans per Attitude span") +
  theme(text = element_text(size=txtsize))

## Same, but looking only where gra/att < 1
df = subset(graduation.comment.counts, gra.att < 1, select = c('comment', 'gra.att'))
# density
ggplot(mapping=aes(df$gra.att)) + geom_density(fill = "purple", alpha = fill.alpha) +
  labs(title = "Graduation spans per Attitude span", x = "Graduation spans per Attitude span") +
  theme(text = element_text(size=txtsize))
# hist
ggplot(mapping=aes(df$gra.att)) + geom_histogram() +
  labs(title = "Graduation spans per Attitude span", x = "Graduation spans per Attitude span") +
  theme(text = element_text(size=txtsize))

## Percent distribution of force and focus
# Shows that there's only a slightly higher tendency to use only focus than mix it evenly with Force, and most use Force exclusively
df = graduation.comment.counts[graduation.comment.counts$forcepct > 0 | graduation.comment.counts$focuspct > 0,]   # filters out comments with no Force/Focus
difference = df$forcepct - df$focuspct
# as density plot
ggplot(mapping=aes(difference)) + geom_density(fill = "purple", alpha = fill.alpha) +
  labs(title = "Preference for Force in Graduation, by comment", x = "Percent of Force spans - percent of Focus spans") +
  theme(text = element_text(size=txtsize))
# as histogram
ggplot(mapping=aes(difference)) + geom_histogram() +
  labs(title = "Tendency towards Force in Graduation, by comment", x = "Percent of Force spans - percent of Focus spans")

## Percent distribution of up and down
# Shows that there's only a slightly higher tendency to use only up than mix it evenly with down, and most use up exclusively
df = graduation.comment.counts[graduation.comment.counts$uppct > 0 | graduation.comment.counts$downpct > 0,]   # filters out comments with no Force/Focus
difference = df$uppct - df$downpct
ggplot(mapping=aes(difference)) + geom_density(fill = "purple", alpha = fill.alpha) +
  labs(title = "Tendency towards upwards Graduation, by comment", x = "Percent of upward Graduation - percent of downward Graduation") +
  theme(text = element_text(size=txtsize))

##### Correlations #####
# Correlation between tendency for negativity and tendency for appreciation
df = subset(comment.counts, select = c("comment", "pospct", "negpct", "judpct", "apppct"))
df$negtend = df$pospct - df$negpct
df$apptend = df$apppct - df$judpct
df <- subset(df, !is.na(negtend) & !is.na(apptend))
cor(df$negtend, df$apptend)

# Correlation between tendency for force and tendency for up
df = data.frame(force = graduation.comment.counts$forcepct - graduation.comment.counts$focuspct,
                up = graduation.comment.counts$uppct - graduation.comment.counts$downpct)
cor(df$force, df$up)

##### Exporting #####
export.folder = 'C:/Users/lcava/Documents/_My Actual Folders/Research/Discourse Processing/socc_comments/analysis/'
write.csv(comment.counts, paste(export.folder,'comment_counts.csv'))
write.csv(graduation.ambig, paste(export.folder, 'ambiguous_graduation.csv'))
write.csv(attcounts, paste(export.folder, 'attitude_counts.csv'))
write.csv(gracounts, paste(export.folder, 'graduation_counts.csv'))
write.csv(negcounts, paste(export.folder, 'negation_counts.csv'))
